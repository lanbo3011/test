#ifndef _IORT_H
#define _IORT_H
/**
 *
 * @file IORT.h
 * 
 * @brief API to expose IO Remapping Table information to SMMU driver.
 *
 * This module will provide API access to IO Remapping Table hardware 
 * information. Although this API does not require clients to be aware of the
 * details of the storage of the information (ACPI, IORT, DeviceTree, Device
 * Configuration, etc.), the information provided by the API is largely aligned
 * with the data specified in the IO Remapping Table specification.
 * 
 * This API provides access to information about the following types of Nodes
 * defined in the IORT specification:
 * * Named Component, identified by a string name.
 * * SMMUv1, SMMUv2, identified by their Base Address.
 * * Root Complex, identified by PCI Segment number.
 * * ITS. Not yet supported.
 * * SMMUv3. Not yet supported.
 *
 * Copyright (c) 2017 Qualcomm Technologies, Inc.
 * All Rights Reserved.
 * Confidential and Proprietary - Qualcomm Technologies, Inc.
 *
 */

#include "api/services/IxErrno.h"
#include "com_dtypes.h"

/**
 * @brief SMMUv1/SMMUv2 Models Enumeration
 *
 */
typedef enum {
    /** Generic SMMUv1 */
    IORT_MODEL_GENERIC_SMMUV1 = 0,
    /** Generic SMMUv2 */
    IORT_MODEL_GENERIC_SMMUV2 = 1,
    /** ARM Corelink MMU-400 */
    IORT_MODEL_ARM_CORELINK_MMU_400 = 2,
    /** ARM Corelink MMU-500 */
    IORT_MODEL_ARM_CORELINK_MMU_500 = 3,
    
    /** Force the Enumeration to be 32-bit */
    IORT_MODEL_MAX_ENUM = 0x7FFFFFFF
} IORT_SMMUv1v2Model;

/**
 * @brief SMMUv1/SMMUv2 Interrupt Type Enumeration
 *
 */
typedef enum {
    /** Context Interrupt Type */
    IORT_SMMUv1v2_INTTYPE_CONTEXT,
    /** PMU Type */
    IORT_SMMUv1v2_INTTYPE_PMU
} IORT_SMMUv1v2IntType;

/**
 * @brief ID Mappings information
 *
 * Contains information about an ID Mapping.
 */
typedef struct _IORT_IDMapping {
    /** Base of ID space for this mapping at the input of the device */
    uint32 InputBase;
    /** Number of IDs in this mapping */
    uint32 NumIDs;
    /** Base of ID space for this mapping at the output of the device */
    uint32 OutputBase;
    /** Base Address of the SMMU to which the output is connected. */
    uint64 OutputSMMUBaseAddr;
    /** Flags associated with this mapping */
    uint32 Flags;
} IORT_IDMapping;

/**
 * @brief Information structure for Named Component
 *
 * Contains Information about a named component
 */
typedef struct _IORT_NamedComponentInfo {
    /** Number of ID mappings existing for the device */
    uint32 NumIDMappings;
    /** Reserved. No Flags defined at present. */
    uint32 Flags;
    /** Cache Coherent Attribute. 
        0x1 - The device is fully coherent.
        0x0 - The device is no coherent. */
    uint32 CacheCoherentAttr;
    /** Allocation Hints.
        Bits [7:4]: set to 0
        Bit    [3]: Allocation Hints Override (AHO).
                    0: Use the incoming Read Allocate (RA),
                       Write Allocate (WA), and Transient (TR) hints.
                    1: If the bit is set, override allocation hints
                       based on the values in bits RA, WA, and TR.
        Bit    [2]: Read Allocate (RA).
                    0: Clear read allocation hint if AHO is set to 1.
                    1: Set read allocation hint if AHO is set to 1.
        Bit    [1]: Write Allocate (WA).
                    0: Clear write allocation hint if AHO is set to 1.
                    1: Set write allocation hint if AHO is set to 1.
        Bit    [0]: Transient (TR).
                    0: Clear transient hint if AHO is set to 1.
                    1: Set transient hint if AHO is set to 1.
         */
    uint8 AllocationHints;
    /** Memory Access Flags (Reference IORT Specification Table 14)
        Bits [7:2]: set to 0
        Bit    [1]: DACS: Device attributes are Cacheable and Inner-Shareable:
                    0: The device does not output IWB-OWB-ISH attributes.
                    1: The device outputs IWB-OWB-ISH attributes.
        Bit    [0]: CPM: Coherent Path to Memory:
                    0: The device does not have a path to memory that is
                       coherent with the CPU cache hierarchy.
                    1: The device has a path to memory that allows coherency
                       with the CPU cache hierarchy.
    */
    uint8 MemoryAccessFlags;
    /** Memory Access Size Limit. The number of address bits, starting from
        the least significant bit, that can be generated by a device when it
        accesses memory. */
    uint8  MemSizeLimit;
} IORT_NamedComponentInfo;

/** If this flag is set, the interrupt is edge-triggered. If not set, the 
    interrupt is level-triggered. */
#define IORT_INTFLAG_EDGE_TRIGGER 0x00000001

/**
 * @brief IORT Interrupt Information structure
 *
 * Interrupt information
 */
typedef struct _IORT_InterruptInfo {
    /** Interrupt Vector */
    uint32 Vector;
    /** Interrupt Flags */
    uint32 Flags;
} IORT_InterruptInfo;

/**
 * @brief SMMUv1 / SMMUv2 information
 *
 * This structure will contain information about SMMUs based on SMMUv1 or
 * SMMUv2 architecture.
 *
 */
typedef struct _IORT_SMMUv1v2Info {
    /** Number of ID mappings existing for the device */
    uint32 NumIDMappings;
    /** SMMU Base Address */
    uint64 BaseAddr;
    /** Length of the memory range that is covered by SMMU memory-mapped IO */
    uint64 Span;
    /** Model of the SMMU */
    IORT_SMMUv1v2Model Model;
    /** Flags */
    uint32 Flags;
    /** Number of Context Bank Interrupts */
    uint32 NumCtxtIrpts;
    /** Number of PMU Interrupts */
    uint32 NumPMUIrpts;
    /** NSgIrpt information */
    IORT_InterruptInfo NSgIrpt;
    /** NSgCfgIrpt information */
    IORT_InterruptInfo NSgCfgIrpt;
} IORT_SMMUv1v2Info;

/** If this flag is set, this indicates the SMMU supports Distributed Virtual
    Memory (DVM) messages and therefore supports broadcast TLB maintenance 
    operations. */
#define IORT_SMMUFLAG_DVM_SUPPORTED 0x00000001 
/** If this flag is set, the page table walk done by the SMMU is coherent with
    CPU caches */
#define IORT_SMMUFLAG_COHERENT_PTW  0x00000002 

/**
 * @brief Return information about the Named Component
 *
 * This API will return information about the Named Component specified in the
 * DevObjName parameter. When called, the pDevInfo parameter shall point
 * to valid memory large enough to hold a IORT_NamedComponentInfo structure.
 *
 * @return IxErrnoType error code
 */
IxErrnoType IORT_GetNamedComponentInfo( 
    /** [in]  Device Object Name */
    char *DevObjName,
    /** [out] Pointer to structure to be populated with the Device 
              information */
    IORT_NamedComponentInfo *pNamedComponentInfo
);

/**
 * @brief Return an array containing the ID mappings for the NamedNode
 *
 * This API returns an array of IORT_IDMapping structures for the device
 * specified by DevObjName, starting with ID Mapping IDMappingIdx.
 *
 * @return IxErrnoType error code
 */
IxErrnoType IORT_GetDeviceSMMUIDMappings (
    /** [in] Device Object Name */
    char *DevObjName,
    /** [in] ID Mapping Index from which to start filling the memory at 
             pIDMappings. */
    uint32 IDMappingIdx,
    /** [in] Number of ID Mappings that will fit in the memory pointed by
             pIDMappings */
    uint32 NumIDMappings,
    /** [out] Pointer to block of memory where the ID Mappings shall be 
              filled */
    IORT_IDMapping *pIDMappings
);

/**
 * @brief Return information about the SMMU instance
 *
 * @return IxErrnoType error code
 */
IxErrnoType IORT_GetSMMUv1v2Info(
    /** [in] SMMU Instance Base Address */
    uint64 BaseAddr,
    /** [out] Pointer to IORT_SMMUv1v2Info structure */
    IORT_SMMUv1v2Info *pSMMUInfo
);

/**
 * @brief Return information about the SMMU interrupts
 *
 * @return IxErrnoType error code
 */
IxErrnoType IORT_GetInterruptInfo(
    /** [in] SMMU Instance Base Address */
    uint64 BaseAddr,
    /** [in] Type of Interrupts to retrieve information about */
    IORT_SMMUv1v2IntType IntType,
    /** [in] Index from where to start filling the pIntInfo array */
    uint32 IntIdx,
    /** [in] Number of IORT_InterruptInfo structures that will fit in the 
             memory pointed to by pIntInfo */
    uint32 NumInts, 
    /** [out] Pointer to memory to allocated to receive the IORT_InterruptInfo 
              array */
    IORT_InterruptInfo *pIntInfo 
);

/**
 * @brief Return a list of SMMU Base Addresses present in the system
 *
 * This API provides information about the number of SMMUv1 and SMMUv2
 * instances present in the system, as well as their base addresses.
 *
 * @return IxErrnoType error code
 */
IxErrnoType IORT_GetSMMUv1v2Instances(
    /** [inout] On input, this shall point to a uint32 that describes the
                number of uint64 allocated and pointed to by pInstanceIDs.
                Upon return, this shall be set to the total number of SMMUv1
                and SMMUv2 instances present in the system. */
    uint32* pNumInstances,
    /** [out] This shall be an array of uint64 that will be filled with the
              base addresses of the SMMUs present in the system. */
    uint64* pBaseAddrs
);

#endif /* _IORT_H */
